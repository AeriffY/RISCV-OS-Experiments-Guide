# 无名管道（pipe）进程间通信实验指导

## 一、本节内容导读（知识点）

本实验围绕 **Linux 中的无名管道（Anonymous Pipe）机制**展开，重点理解以下操作系统核心概念：

* 进程间通信（IPC）的基本需求与实现方式
* 无名管道的内核实现模型与数据流方向
* 文件描述符在进程间通信中的作用
* 父子进程之间的协作与职责分离
* 阻塞式 I/O 与同步通信特性
* 无名管道的本质
  
    无名管道（pipe）是一种最古老的 UNIX 进程间通信机制，具有如下本质特征：

    * 无名管道是内核空间中的一块缓冲区
    * 不属于任何文件系统，仅存在于内存中
    * 在用户态表现为两个文件描述符
      * 一个负责读
      * 一个负责写
  
    在 Linux 中，每个进程拥有独立的4GB 虚拟地址空间（经典模型）：
    * 3GB 用户空间（私有）
    * 1GB 内核空间（所有进程共享）

    > 无名管道正是创建在内核空间中。
    多个进程只要持有指向同一管道的文件描述符，就可以通过它进行通信。

* 管道的基本特性

    无名管道具有如下重要特性：

    - 半双工通信：同一时刻数据只能单向流动
    - 单向数据流：一端写入，另一端读取
    - 先进先出（FIFO）：保证数据顺序
    - 无格式字节流：读写双方需事先约定数据格式
    - 一次性读取：数据被读走后即从管道中消失
    - 无名字：只能用于具有亲缘关系的进程
    - 容量有限：内核缓冲区大小有限（常见为 64KB）

通过两个典型实验程序，理解操作系统如何在**进程隔离的前提下**，借助内核缓冲区实现**安全、可靠的数据传递**。

---

## 二、实验目标

通过本实验，要求学生能够：

1. 理解无名管道的本质及其在内核中的存在形式
2. 掌握 pipe()、fork()、read()、write() 等系统调用
3. 理解文件描述符在进程间通信中的关键作用
4. 正确设计父子进程的通信方向与职责分工
5. 理解阻塞 I/O 对进程同步的影响
6. 掌握管道异常情况（EOF、SIGPIPE）的触发条件

---

## 三、无名管道实验内容

### 任务一：单向无名管道的基本通信模型
#### （1）实验目的
该实验使用**一个无名管道**实现父进程向子进程发送数据：

* 父进程：写数据
* 子进程：读数据

这是无名管道最基本、也是最典型的使用方式。

#### （2）无名管道的创建 -- pipe函数
```c
#include <unistd.h>
int pipe(int pipefd[2]);
```
- 功能：创建一个无名管道，返回两个文件描述符负责对管道进行读写操作
- 参数：
  - pipefd：int型数组的首地址，里面有两个元素
  - pipefd[0] 负责对管道执行读操作
  - pipefd[1] 负责对管道执行写操作
- 返回值：
  - 成功：0
  - 失败：‐1

示例代码：单进程读写管道（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\01_pipe_basic_parent_child.c）

#### 1. 创建管道

```c
int filedes[2];   // filedes[0]：读端，filedes[1]：写端

// 创建无名管道
if (pipe(filedes) < 0) {
    printf("pipe error");
    return -1;
}
```

【代码详解】：

* `pipe(filedes)` 成功返回 0，失败返回 -1
* 成功时，`filedes` 数组中存放读端和写端的文件描述符

---

#### 2. 创建子进程

```c
if (fork() > 0) {
    // 父进程
} else {
    // 子进程
}
```

【代码详解】：

* 使用 `fork()` 创建父子进程
* 父进程写数据，子进程读数据

---

#### 3. 父进程写管道

```c
char s[] = "hello!\n";

close(filedes[0]);                // 关闭读端
write(filedes[1], s, sizeof(s));  // 写入管道
close(filedes[1]);                // 关闭写端
```

【代码详解】：

* 父进程只需要写端，因此关闭读端
* `write()` 将数据写入管道，子进程可读取
* 写完后关闭写端，通知读端 EOF

---

#### 4. 子进程读管道

```c
char buffer[80];

close(filedes[1]);                // 关闭写端
read(filedes[0], buffer, 80);     // 从管道读取数据
printf("%s", buffer);
close(filedes[0]);                // 关闭读端
```

【代码详解】：

* 子进程只需要读端，因此关闭写端
* `read()` 会阻塞，直到有数据写入或写端关闭
* 读完后关闭读端

---
### 任务二：管道读写行为规律分析
#### 2.1 读写端都存在，只读不写
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\02_pipe_read_only_block.c）
#### （1）实验目的

* 观察在管道读写端都存在时，只进行读操作的阻塞行为。
* 理解阻塞读模型：当管道中无数据时，`read()` 会等待数据到来。
  
#### （2）实验步骤

#### 1. 创建管道

```c
int pipefd[2];

if (pipe(pipefd) == -1)
{
    perror("fail to pipe");
    exit(1);
}
```

【代码详解】：

* `pipe(pipefd)` 创建无名管道
* `pipefd[0]` 为读端，`pipefd[1]` 为写端
* 成功返回 0，失败返回 -1

---

#### 2. 向管道写入数据

```c
write(pipefd[1], "hello world", 11);
```
【代码详解】：

* 向管道写入字符串 `"hello world"`
* 这步是为了演示第一次读操作能够立即读取数据
* 写入的数据存入管道缓冲区

---

#### 3. 第一次读取管道数据

```c
char buf[128] = "";

if (read(pipefd[0], buf, sizeof(buf)) == -1)
{
    perror("fail to read");
    exit(1);
}

printf("buf = %s\n", buf);
```
【代码详解】：
* 从管道读端读取数据
* 管道中有数据，`read()` 成功返回读取的字节数
* 打印结果应为 `"hello world"`

---

#### 4. 第二次读取管道数据（阻塞情况）

```c
if (read(pipefd[0], buf, sizeof(buf)) == -1)
{
    perror("fail to read");
    exit(1);
}

printf("buf = %s\n", buf);
```

【代码详解】：

* 第二次读取时管道中无数据
* `read()` 会阻塞，等待写入数据
* 此时程序会停在 `read()` 位置，直到有数据写入

---

#### 2.2 读写端都存在，只写不读
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\03_pipe_write_only_block.c）
#### （1）实验目的
* 观察在管道读写端都存在时，只进行写操作的阻塞行为。
* 理解阻塞写模型：当管道缓冲区写满时，`write()` 会等待读端读取数据。
* 了解管道的流量控制作用。

---

#### （2）实验步骤

#### 1. 创建管道

```c
int pipefd[2];

if (pipe(pipefd) == -1)
{
    perror("fail to pipe");
    exit(1);
}
```

【代码详解】：

* `pipe(pipefd)` 创建无名管道
* `pipefd[0]` 为读端，`pipefd[1]` 为写端
* 成功返回 0，失败返回 -1

---

#### 2. 持续写入管道数据

```c
int num = 0;

while (1)
{
    if (write(pipefd[1], "6666", 1024) == -1)
    {
        perror("fail to write");
        exit(1);
    }
    
    num++;
    printf("num = %d\n", num);
}
```
【代码详解】：

* 持续向管道写入数据 `"6666"`
* 无读端消费数据时，管道缓冲区会被写满
* 当缓冲区满时，`write()` 阻塞等待，直到有数据被读取
* `num` 用于记录写入次数，方便观察阻塞发生的位置
---

#### 2.3 只有读端，没有写端
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\04_pipe_eof_read.c）
#### （1）实验目的

* 观察在管道中只有读端，没有写端时的行为。
* 理解 `read()` 在无写端情况下的返回特性：如果管道空且写端已关闭，`read()` 返回 0（EOF）。

---

#### （2）实验步骤

#### 1. 创建管道

```c
int pipefd[2];

if (pipe(pipefd) == -1)
{
    perror("fail to pipe");
    exit(1);
}
```

【代码详解】：

* `pipe(pipefd)` 创建无名管道
* `pipefd[0]` 为读端，`pipefd[1]` 为写端
* 成功返回 0，失败返回 -1

---

#### 2. 向管道写入数据，然后关闭写端

```c
write(pipefd[1], "hello world", 11);
close(pipefd[1]); // 关闭写端，只保留读端
```

【代码详解】：

* 向写端写入数据 `"hello world"`
* 关闭写端后，管道中只剩读端
* 后续读操作只能读取已有数据，不能再写入

---

#### 3. 第一次读取管道数据

```c
char buf[128] = "";
ssize_t bytes;

bytes = read(pipefd[0], buf, sizeof(buf));
printf("bytes = %ld\n", bytes);
printf("buf = %s\n", buf);
```

【代码详解】：

* 读端读取到管道中已有数据
* 返回值 `bytes` 表示实际读取的字节数
* 管道数据会被清空

---

#### 4. 第二次读取，管道为空且写端已关闭

```c
memset(buf, 0, sizeof(buf));
bytes = read(pipefd[0], buf, sizeof(buf));
printf("bytes = %ld\n", bytes);
printf("buf = %s\n", buf);
```

【代码详解】：

* 此时管道中没有数据，写端已关闭
* `read()` 返回 0，表示 EOF
* buf 内容为空

---

#### 5. 关闭读端

```c
close(pipefd[0]);
```

【代码详解】：

* 释放读端文件描述符资源
* 实验结束

---
#### 2.4 只有写端，没有读端
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\05_pipe_sigpipe.c）
#### （1）实验目的

* 观察在管道只有写端而没有读端时的行为。
* 理解 `SIGPIPE` 信号的产生机制及默认处理方式。
* 学习使用 `signal(SIGPIPE, handler)` 捕捉无接收者写入管道的情况。

---

#### （2）实验步骤

#### 1. 注册 SIGPIPE 信号处理函数

```c
#include <signal.h>

void handler(int sig)
{
    printf("SIGPIPE信号产生了，管道破裂了\n");
}
```
【代码详解】：

* 当写入管道时，如果没有读端，内核会向写进程发送 `SIGPIPE` 信号
* 默认行为是终止进程
* 使用 `signal(SIGPIPE, handler)` 可以捕捉该信号并执行自定义处理

---

#### 2. 创建管道并关闭读端

```c
int pipefd[2];

if (pipe(pipefd) == -1)
{
    perror("fail to pipe");
    exit(1);
}

// 关闭读端，只保留写端
close(pipefd[0]);
```
【代码详解】：

* `pipe(pipefd)` 创建无名管道
* 关闭读端后，管道变为“只有写端”
* 此时对写端执行写操作可能触发 `SIGPIPE`

---

#### 3. 持续写入管道

```c
int num = 0;

while (1)
{
    if (write(pipefd[1], "hello world", 1024) == -1)
    {
        perror("fail to write");
        exit(1);
    }
    
    num++;
    printf("num = %d\n", num);
}
```
【代码详解】：

* 持续向管道写入数据 `"hello world"`
* 当管道没有读端时，第一次写操作就会触发 `SIGPIPE`
* 注册了信号处理函数后，不会退出，而是打印提示信息
* `num` 用于记录写入次数，可观察写入是否被中断

### 任务三：双向通信的无名管道协作模型
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\06_pipe_bidirectional.c）
#### （1）实验目的

* 实现父子进程间双向通信：

  * 父进程：读取数据 → 发送给子进程 → 接收计算结果并显示
  * 子进程：接收数据 → 执行计算 → 将结果返回父进程
* 理解无名管道的阻塞与同步特性
* 学习如何用两个管道实现父子进程的双向通信

---

#### （2）实验步骤与代码

#### 1. 创建双管道并 fork 子进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>

#define BUF_SIZE 128

int main()
{
    int p2c[2]; // 父 → 子
    int c2p[2]; // 子 → 父

    pipe(p2c); // 创建父到子的管道
    pipe(c2p); // 创建子到父的管道

    pid_t pid = fork();
```

【代码详解】：

* `pipe(p2c)`、`pipe(c2p)` 创建两个无名管道
* `p2c` 用于父进程发送数据给子进程
* `c2p` 用于子进程返回计算结果给父进程
* `fork()` 产生父子进程

---

#### 2. 子进程逻辑：接收数据、计算、返回结果

```c
    if (pid == 0) {
        // 子进程
        close(p2c[1]); // 关闭写端，只读父发的数据
        close(c2p[0]); // 关闭读端，只写返回数据

        int num;
        while (read(p2c[0], &num, sizeof(int)) > 0) {
            int result = num * 10;
            write(c2p[1], &result, sizeof(int));
        }

        close(p2c[0]);
        close(c2p[1]);
        exit(0);
    }
```
【代码详解】：

* 关闭不使用的管道端口，避免写入阻塞
* `read(p2c[0], &num, sizeof(int))` 阻塞直到父进程写入数据
* 子进程计算 `num * 10` 并通过 `write(c2p[1], &result, sizeof(int))` 返回
* 管道关闭后退出

---

#### 3. 父进程逻辑：读取文件、发送数据、接收结果

```c
    // 父进程
    close(p2c[0]); // 关闭读端，只写数据
    close(c2p[1]); // 关闭写端，只读结果

    int fd = open("data.txt", O_RDONLY);
    char buf[BUF_SIZE + 1];

    while (read(fd, buf, BUF_SIZE) > 0) {
        char *token = strtok(buf, " \n");
        while (token) {
            int num = atoi(token);
            write(p2c[1], &num, sizeof(int));

            int result;
            read(c2p[0], &result, sizeof(int));
            printf("计算结果：%d\n", result);

            token = strtok(NULL, " \n");
        }
    }

    close(fd);
    close(p2c[1]);
    close(c2p[0]);
    wait(NULL);
    return 0;
}
```
【代码详解】：

* 父进程只写 `p2c[1]`，只读 `c2p[0]`
* 从文件中读取数字字符串 → 转为整数 → 写入管道
* 阻塞 `read(c2p[0], &result, sizeof(int))` 等待子进程返回结果
* 使用 `wait(NULL)` 等待子进程结束，确保资源回收

### 任务四：通过fcntl函数设置文件的阻塞特性
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\07_pipe_nonblock.c）
#### （1）实验目的

* 理解阻塞与非阻塞模式下 `read()` 的行为差异
* 学习使用 `fcntl()` 设置文件描述符为非阻塞模式
* 观察管道中无数据时，父进程的非阻塞读取效果

---

#### （2）实验步骤

#### 1. 创建无名管道并 fork 子进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int fd_pipe[2];
    char buf[] = "hello world";
    pid_t pid;

    if (pipe(fd_pipe) < 0)
    {
        perror("fail to pipe");
        exit(1);
    }

    pid = fork();

    if (pid < 0)
    {
        perror("fail to fork");
        exit(1);
    }
```

【代码详解】：

* `pipe(fd_pipe)` 创建无名管道
* `fd_pipe[0]` 为读端，`fd_pipe[1]` 为写端
* `fork()` 创建父子进程

---

#### 2. 子进程逻辑：定时写入数据

```c
    if (pid == 0)
    {
        // 子进程：每隔5秒写入一次数据
        while (1)
        {
            sleep(5);
            write(fd_pipe[1], buf, strlen(buf));
        }
    }
```

【代码详解】：

* 子进程每 5 秒写入一次 `"hello world"`
* 写操作阻塞时，如果管道满，会等待管道可写

---

#### 3. 父进程逻辑：非阻塞读取

```c
    else
    {
        // 父进程：设置为非阻塞读取
        // 默认是阻塞模式
        // fcntl(fd_pipe[0], F_SETFL, 0);  // 阻塞模式

        // 设置为非阻塞模式
        fcntl(fd_pipe[0], F_SETFL, O_NONBLOCK);

        while (1)
        {
            memset(buf, 0, sizeof(buf));
            read(fd_pipe[0], buf, sizeof(buf));
            printf("buf=[%s]\n", buf);
            sleep(1);
        }
    }

    return 0;
}
```

【代码详解】：

* `fcntl(fd_pipe[0], F_SETFL, O_NONBLOCK)` 将读端设置为非阻塞
* 非阻塞模式下：

  * 管道中有数据 → `read()` 正常读取
  * 管道中无数据 → `read()` 立即返回，不阻塞
* 父进程每秒打印一次读取结果

---

## 四、文件描述符实验内容
### 概述
1. 文件描述符是非负整数，是文件的标识。
2. 用户使用文件描述符（file descriptor）来访问文件。
3. 利用open打开一个文件时，内核会返回一个文件描述符。
4. 每个进程都有一张文件描述符的表，进程刚被创建时，标准输入、标准输出、标准错误输出。
5. 设备文件被打开，对应的文件描述符0、1、2 记录在表中。
6. 在进程中打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。

**注意：**
- Linux中一个进程最多只能打开NR_OPEN_DEFAULT（即1024）个文件，故当文件不再使用时应及时调用close函数关闭文件。

（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\08_fd_open_limit.c）
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
    // 在进程中打开其他文件时，
    // 系统会返回文件描述符表中最小可用的文件描述符，
    // 并将此文件描述符记录在进程的文件描述符表中。
    // 注意：新创建的文件描述符的值不一定是最大的

#if 0
    close(0);

    int fd1, fd2, fd3;
    fd1 = open("file.txt", O_RDONLY | O_CREAT, 0664);
    fd2 = open("file.txt", O_RDONLY | O_CREAT, 0664);
    fd3 = open("file.txt", O_RDONLY | O_CREAT, 0664);

    printf("fd1 = %d\n", fd1);
    printf("fd2 = %d\n", fd2);
    printf("fd3 = %d\n", fd3);
#endif

    // Linux中一个进程最多只能打开 NR_OPEN_DEFAULT（即1024）个文件，
    // 故当文件不再使用时应及时调用 close 函数关闭文件
    int fd;
    while (1)
    {
        if ((fd = open("file.txt", O_RDONLY | O_CREAT, 0664)) < 0)
        {
            perror("fail to open");
            exit(1);
        }

        printf("fd = %d\n", fd);
    }

    return 0;
}
```
### 文件描述符的复制
#### 4.1 dup函数
```
#include <unistd.h>
int dup(int oldfd);
```
- 功能：复制oldfd文件描述符，并分配一个新的文件描述符，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符。
- 参数：
  - 要复制的文件描述符oldfd。
- 返回值：
  - 成功：新文件描述符。
  - 失败：返回－1，错误代码存于errno中。
---
#### 4.1.1 使用dup函数复制文件描述符
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\09_dup_basic.c）
#### （1）实验目的

* 学习 `dup()` 函数
* 理解复制文件描述符后的行为
* 掌握向终端写入数据

---
#### （2）实验步骤
#### 1. 复制标准输出文件描述符

```c
int fd;
fd = dup(1); // 复制标准输出（fd=1），返回新的文件描述符 fd
```

【代码详解】：
* `dup(1)` 会返回文件描述符表中最小可用的 fd，并指向与 fd=1 相同的文件/终端
* 新 fd 与标准输出共享同一个文件表项

---

#### 2. 打印新文件描述符

```c
printf("fd = %d\n", fd); // 打印新文件描述符
```
【代码详解】：
* 验证新复制的文件描述符
* 输出到终端，因为标准输出仍然指向终端

---

#### 3. 通过新文件描述符写数据

```c
write(fd, "nihao beijing\n", strlen("nihao beijing\n"));
```
【代码详解】：
* 通过新 fd 输出数据
* 实际效果等同于向终端写入数据

---

#### 4. 结束程序

```c
return 0;
```
【代码详解】：
* 系统会自动关闭程序中打开的文件描述符
  
---

#### 4.1.2 实现输出重定向的功能
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\010_dup_redirect.c）
#### （1）实验目的

* 将标准输出重定向到文件
* 学习 `open()`、`close()` 和 `dup()` 的组合使用

---
#### （2）实验步骤
#### 1. 打开目标文件

```c
int fd_file;
fd_file = open("test.txt", O_WRONLY | O_CREAT | O_TRUNC, 0664); // 打开文件用于写入，文件不存在则创建
```

【代码详解】：
* `O_WRONLY`：只写
* `O_CREAT`：不存在则创建
* `O_TRUNC`：存在则清空
* 权限 `0664`：用户读写，组读，其他读

---

#### 2. 关闭标准输出

```c
close(1); // 关闭标准输出文件描述符
```
【代码详解】：

* 标准输出 fd=1 被关闭
* 下一步 `dup()` 可以占用 fd=1

---

#### 3. 复制文件描述符到标准输出

```c
int fd;
fd = dup(fd_file); // 将文件 fd_file 复制到最小可用 fd（此时为1）
```
【代码详解】：

* `dup(fd_file)` 会返回最小可用 fd，即刚刚关闭的 fd=1
* 之后 printf() 输出会写入 test.txt 文件

---

#### 4. 打印测试信息

```c
printf("hello world\n");
printf("fd = %d\n", fd);
```
【代码详解】：

* 输出内容重定向到文件
* 验证新 fd

---

#### 5. 结束程序

```c
return 0;
```

---

#### 4.1.3 实现输出重定向后，还想标准输出，如何实现
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\011_dup_restore_stdout.c）
#### （1）实验目的

* 在输出重定向后恢复标准输出到终端
* 掌握 `dup()` 保存原文件描述符的方法

---
#### （2）实验步骤
#### 1. 保存原标准输出

```c
int fd2;
fd2 = dup(1); // 复制标准输出，保存到 fd2，用于后续恢复
printf("new: fd2 = %d\n", fd2);
```
【代码详解】：
* 保存原始终端输出文件描述符
* 后续可以用 fd2 恢复输出

---

#### 2. 打开文件用于重定向

```c
int fd1;
fd1 = open("test.txt", O_RDWR | O_CREAT, 0664); // 打开文件用于重定向输出
```
【代码详解】：

* `O_RDWR` 可读写
* 文件不存在则创建
* 权限 0664

---

#### 3. 关闭标准输出并重定向

```c
close(1);       // 关闭标准输出
int fd3 = dup(fd1); // 将 fd1 复制到 fd=1，实现重定向
```
【代码详解】：

* printf() 输出写入 test.txt
* fd3 等于 1

---

#### 4. 打印重定向信息

```c
printf("hello world\n");
printf("fd = %d\n", fd3);
```
【代码详解】：

* 输出写入文件
* 验证文件描述符

---

#### 5. 恢复标准输出到终端

```c
close(1);       // 关闭重定向的标准输出
int fd4 = dup(fd2); // 将原始终端 fd2 复制到 fd=1
printf("nihao beijing\n");
printf("fd = %d\n", fd4);
```
【代码详解】：
* printf() 输出恢复到终端
* fd4 等于 1

---

#### 6. 结束程序

```c
return 0;
```

#### 4.2 dup2函数
```c
#include <unistd.h>
int dup2(int oldfd, int newfd)
```
- 功能：复制一份打开的文件描述符oldfd，并分配新的文件描述符newfd，newfd也标识oldfd所标识的文件。
- 注意：
  - newfd是小于文件描述符最大允许值的非负整数，如果newfd是一个已经打开的文件描述符，则首先关闭该文件，然后再复制。
- 参数：
  - oldfd：要复制的文件描述符
  - newfd：分配的新的文件描述符
- 返回值：
  - 成功：返回newfd
  - 失败：返回‐1，错误代码存于errno中
#### 4.2.1 实现输出重定向
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\012_dup2_redirect_restore.c）
#### （1）实验目的

* 将标准输出重定向到文件
* 学习 `dup2()` 的使用

---
#### （2）实验步骤
#### 1. 打开目标文件

```c
int fd1;
fd1 = open("test.txt", O_CREAT | O_WRONLY, 0664); // 打开文件 test.txt，用于写入
```
【代码详解】：
* `O_CREAT`：若文件不存在则创建
* `O_WRONLY`：只写
* 权限 `0664`

---

#### 2. 将 fd1 复制到标准输出

```c
int fd2;
fd2 = dup2(fd1, 1); // 将 fd1 复制到 fd=1（标准输出），返回值为新文件描述符
```
【代码详解】：

* `dup2(oldfd, newfd)` 会把 oldfd 的文件指向复制给 newfd
* 这里 newfd=1（标准输出）
* printf() 输出会写入 test.txt 文件

---

#### 3. 打印测试信息

```c
printf("hello world\n");
printf("fd2 = %d\n", fd2);
```
【代码详解】：

* 输出重定向到 test.txt
* 验证 dup2 返回值 fd2

---

#### 4. 结束程序

```c
return 0;
```

---
#### 4.2.2 实现输出重定向后，再恢复标准输出
（源码请见RISCV-OS-Experiments-Guide\src\进程间通信与管道实验\013_dup2_redirect_stdout.c）
#### （1）实验目的

* 输出重定向到文件
* 恢复标准输出到终端
* 掌握 `dup2()` 保存和恢复文件描述符的方法

---
#### （2）实验步骤
#### 1. 保存原标准输出

```c
int fd2 = 3;
dup2(1, fd2); // 将标准输出 fd=1 复制到 fd2，用于后续恢复
printf("fd2 = %d\n", fd2);
```
【代码详解】：

* fd2 保存原终端输出
* printf() 仍然输出到终端

---

#### 2. 打开文件用于重定向

```c
int fd1;
fd1 = open("test.txt", O_CREAT | O_RDWR, 0664); // 打开或创建文件 test.txt，可读写
```
【代码详解】：

* `O_RDWR`：可读可写
* 权限 0664

---

#### 3. 重定向标准输出到文件

```c
dup2(fd1, 1); // 关闭标准输出 fd=1，然后复制 fd1 给 fd=1
printf("hello world\n"); // 输出写入 test.txt
```
【代码详解】：

* printf() 的输出现在写入文件
* 不再显示在终端

---

#### 4. 恢复标准输出到终端

```c
dup2(fd2, 1); // 将原始终端 fd2 复制回 fd=1
printf("你好北京\n"); // 输出回终端
```
【代码详解】：

* printf() 输出恢复到终端
* 可以在输出重定向后恢复原输出

---

#### 5. 结束程序

```c
return 0;
```
---

## 五、观察与思考

1. 如果父进程忘记关闭写端 `p2c[1]`，子进程会发生什么？为什么？
2. 如果将两个管道合并成一个，会产生哪些问题？
3. 管道通信与文件 I/O 在接口上有哪些相似性？
4. 如果子进程处理速度很慢，父进程会被阻塞在什么地方？

---

## 六、实验小结

1. 无名管道本质
   * 无名管道是内核空间中的一块缓冲区，不依赖文件系统，仅存在于内存中。
   * 为具有亲缘关系的进程提供可靠的单向通信通道。

2. 文件描述符在通信中的作用
   * 管道操作依赖文件描述符，`pipe()` 创建的读写端在 `fork()` 后被父子进程继承。
   * 正确关闭不使用的文件描述符，是保证 EOF 正确产生和进程不阻塞的关键。

3. 半双工与双向通信设计
   * 无名管道是半双工，单向传输。
   * 双向通信需要两个管道（父→子、子→父）来实现请求—响应机制。

4. 阻塞与同步特性

   * `read()` 在无数据时阻塞，`write()` 在管道满时阻塞。
   * 这种阻塞特性天然保证了进程间的同步，无需额外锁或信号量。
  
本实验为理解更复杂的进程通信机制（如有名管道、共享内存、消息队列、Socket）打下了坚实基础。
