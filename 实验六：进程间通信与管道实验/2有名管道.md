# 有名管道（FIFO）进程间通信实验指导

## 一、本节内容导读（知识点）

本节实验围绕 Linux 系统中的**有名管道（FIFO）**展开，系统学习 FIFO 的创建方式、读写操作以及在不同进程组合和阻塞/非阻塞条件下的行为特性。通过多个独立小实验，逐步理解 FIFO 的工作原理及其在进程间通信中的应用。

主要知识点包括：
### 1. 有名管道（FIFO）的基本概念与基本特点

* FIFO（First In First Out）是 Linux 系统提供的一种**特殊文件类型**，用于**进程间通信（IPC）**。
* 数据以**先进先出**的顺序在管道中流动。
* 与无名管道不同，FIFO 有**文件名**，存在于文件系统中，因此可以在**不相关进程之间**进行通信。

* FIFO 的主要特点

  - 半双工通信：数据在同一时刻只能沿一个方向流动。
  - 先入先出：写入 FIFO 的数据遵循先进先出规则。
  - 无格式数据：FIFO 传输的是原始字节流，读写双方需事先约定数据格式或消息长度。
  - 文件系统可见：FIFO 在文件系统中作为特殊文件存在，而管道数据本身存储在内核内存中。
  - 缓冲区机制：内核为 FIFO 分配缓冲区，不同系统缓冲区大小可能不同。
  - 一次性读取：读取的数据会从 FIFO 中移除，释放空间供后续写入使用。
  - 持久文件：使用 FIFO 的进程退出后，FIFO 文件仍然保留，可供以后使用。
  - 可供不相关进程通信：由于 FIFO 有名字，任意进程可以通过打开该命名管道进行数据交换。

#### 2. FIFO 与无名管道的区别

| 特性    | 无名管道           | 有名管道（FIFO）               |
| ----- | -------------- | ------------------------ |
| 文件存在性 | 内存中临时存在        | 文件系统中存在特殊文件              |
| 通信进程  | 必须有亲缘关系（如父子进程） | 可以是任意不相关进程               |
| 创建方式  | `pipe()` 系统调用  | `mkfifo()` 系统调用或 `mknod` |
| 双向通信  | 需要两个管道         | 同样需要两个 FIFO 才能实现全双工      |

#### 3. 创建 FIFO

* 使用 `mkfifo` 系统调用：

```c
mkfifo("fifo_name", 0664);
```

* 第一个参数：FIFO 文件名
* 第二个参数：文件权限（如 `0664` 表示用户可读写，组可读写，其他可读）

- 如果 FIFO 已存在，`errno` 返回 `EEXIST`，可直接使用。

#### 4. FIFO 的读写操作及阻塞特性

* 打开 FIFO：

  * 读端：`open("fifo_name", O_RDONLY)`
  * 写端：`open("fifo_name", O_WRONLY)`
* 阻塞行为：

  * **读端阻塞**：管道中无数据时，`read()` 会等待写端写入数据
  * **写端阻塞**：管道缓冲区满时，`write()` 会等待读端读取数据
* 写操作在无读端时会阻塞，防止数据丢失

#### 5. FIFO 在不同读写端组合下的行为规律

| 组合情况        | 行为                      |
| ----------- | ----------------------- |
| 读写端都存在      | 正常通信，读阻塞在无数据时，写阻塞在缓冲区满时 |
| 只有读端        | `open` 阻塞，直到有写端打开       |
| 只有写端        | `open` 阻塞，直到有读端打开       |
| 读写端都存在，只读不写 | `read()` 阻塞等待数据         |
| 读写端都存在，只写不读 | `write()` 阻塞等待缓冲区空位     |

#### 6. FIFO 的非阻塞读写

* 使用 `O_NONBLOCK` 打开 FIFO：

  * 非阻塞读：`read()` 在无数据时立即返回 `-1`，并设置 `errno=EAGAIN`
  * 非阻塞写：`write()` 在无读端或缓冲区满时立即返回 `-1`，并设置 `errno=EAGAIN`

#### 7. 利用 FIFO 实现不相关进程间通信

* 通过两个 FIFO 可以实现**全双工通信**（双向传输）

  * FIFO1：发送数据
  * FIFO2：接收数据
* 常见应用：

  * 两个独立进程之间的消息传递
  * 客户端—服务器模型的简单实现
* 写端阻塞、读端阻塞和同步顺序保证了通信的可靠性

---

## 二、实验目标

1. 掌握有名管道 FIFO 的创建方法
2. 熟悉 FIFO 的基本读写操作
3. 理解 FIFO 的阻塞与非阻塞特性
4. 掌握 FIFO 在不同进程读写组合下的行为规律
5. 能够使用 FIFO 实现进程间通信
6. 通过多个实验现象加深对 FIFO 工作机制的理解

---

## 三、实验内容

---

### 任务一：使用 `mkfifo` 创建有名管道

（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\11_mkfifo_create.c）

#### （1）实验目的

- 学习使用系统调用 `mkfifo()` 创建一个有名管道，并理解 FIFO 在文件系统中的表现形式。
  - 方法一：用shell命令`mkfifo`创建有名管道
    ```
    mkfifo 文件名
    ```
  - 方法二：使用函数`mkfifo`
      ```
      #include <sys/types.h>
      #include <sys/stat.h>
      int mkfifo(const char *pathname, mode_t mode);
      ```
      - 功能：创建一个有名管道，产生一个本地文件系统可见的文件pathname
      - 参数：
      - pathname：有名管道创建后生成的文件，可以带路径
      - mode：管道文件的权限，一般通过八进制数设置即可，例如0664
      - 返回值：
      - 成功：0
      - 失败：‐1
- 理解 FIFO 已存在时的处理方法
- 掌握有名管道在文件系统和内核空间的存储特性

#### （2）实验步骤
##### Step 1：创建有名管道

```c
if (mkfifo("fifo_file", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* `mkfifo("fifo_file", 0664)` 创建一个有名管道

  * `"fifo_file"`：管道文件名
  * `0664`：权限，用户可读写，组可读写，其他可读
* 如果创建失败，检查 `errno`

  * `errno == EEXIST`：管道文件已存在，可直接使用，无需退出
  * 其他错误：输出错误信息并退出

---

##### Step 2：退出程序

```c
return 0;
```

【代码详解】：

* 程序正常结束
* 此时 FIFO 已创建成功或已经存在，可用于后续读写操作
---

### 任务二：有名管道的基本读写操作（单进程）

（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\12_fifo_single_rw.c）
#### （1）实验目的

- 掌握使用 `open`、`write`、`read` 对有名管道进行基本读写操作，并理解有名管道的先进先出特性。
- 由于有名管道在本地创建了一个管道文件，所以系统调用的IO函数基本都可以对有名管道进行操作，但是不能使用lseek修改管道文件的偏移量。
- 注意：有名管道创建的本地的文件只是起到标识作用，真正有名管道实现进程间通信还是在内核空间开辟内存，所以本地产生的文件只是一个标识，没有其他作用，对本地管道文件的操作实质就是对内核空间的操作。

#### （2）实验步骤

##### Step 1：创建有名管道

```c
if (mkfifo(FIFONAME, 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* 使用 `mkfifo(FIFONAME, 0664)` 创建有名管道
* `0664` 表示用户可读写，组可读写，其他可读
* 如果管道已经存在 (`errno == EEXIST`) 则直接使用
* 其他错误则打印并退出

---

##### Step 2：打开有名管道

```c
int fd;
fd = open(FIFONAME, O_RDWR);
if (fd == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* `open(FIFONAME, O_RDWR)` 以可读可写方式打开 FIFO
* 使用 `O_RDWR` 可以避免阻塞，保证程序能同时进行读写
* 返回文件描述符 `fd` 用于后续读写操作

---

##### Step 3：向 FIFO 写入数据

```c
write(fd, "hello world", strlen("hello world"));
write(fd, "nihao beijing", strlen("nihao beijing"));
```

【代码详解】：

* 使用 `write(fd, buf, len)` 向 FIFO 写入数据
* 多次写入的数据会顺序存放在 FIFO 中
* FIFO 是一个字节流，写入不会覆盖已有数据

---

##### Step 4：从 FIFO 读取数据

```c
char buf[32] = "";
if (read(fd, buf, sizeof(buf)) == -1)
{
    perror("fail to read");
    exit(1);
}
printf("buf = [%s]\n", buf);

if (read(fd, buf, sizeof(buf)) == -1)
{
    perror("fail to read");
    exit(1);
}
printf("buf = [%s]\n", buf);
```

【代码详解】：

* 使用 `read(fd, buf, sizeof(buf))` 从 FIFO 中读取数据
* 每次 `read` 会移除已读取的数据
* 读取顺序与写入顺序保持一致

---

##### Step 5：关闭文件描述符

```c
close(fd);
```

【代码详解】：

* 使用 `close(fd)` 关闭文件描述符
* 释放资源，结束对 FIFO 的操作

---

### 任务三：有名管道实现进程间通信
- 由于有名管道在本地创建了一个管道文件，所以不相关的进程间也可以实现通信。

#### 3.1使用 FIFO 实现两个不相关进程通信（send 进程）
（源码请见ORISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\13_fifo_send.c）

#### （1）实验目的

* 学习通过 FIFO 进行进程间通信
* 掌握使用两个 FIFO 实现全双工通信的方法
* 理解写端在无读端时的阻塞行为

---

#### （2）实验步骤

##### Step 1：创建两个 FIFO

```c
if (mkfifo("myfifo1", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}

if (mkfifo("myfifo2", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* `myfifo1` 用于发送数据
* `myfifo2` 用于接收数据
* `0664` 表示权限：用户可读写，组可读写，其他可读
* 如果 FIFO 已存在 (`errno == EEXIST`) 则直接使用
* 其他错误则打印并退出

---

##### Step 2：打开 FIFO 并获取文件描述符

```c
int fd_w, fd_r;

if ((fd_w = open("myfifo1", O_WRONLY)) == -1)
{
    perror("fail to open");
    exit(1);
}

if ((fd_r = open("myfifo2", O_RDONLY)) == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* `fd_w` 用于写入 `myfifo1`
* `fd_r` 用于从 `myfifo2` 读取数据
* `O_WRONLY` / `O_RDONLY` 分别表示写端和读端
* 打开顺序保证了阻塞和同步

---

##### Step 3：循环发送与接收数据

```c
char buf[128] = "";
ssize_t bytes;

while (1)
{
    fgets(buf, sizeof(buf), stdin);
    buf[strlen(buf) - 1] = '\0';

    // 写入 myfifo1
    if ((bytes = write(fd_w, buf, sizeof(buf))) == -1)
    {
        perror("fail to write");
        exit(1);
    }

    // 从 myfifo2 读取回显
    if ((bytes = read(fd_r, buf, sizeof(buf))) == -1)
    {
        perror("fail to read");
        exit(1);
    }

    printf("from recv: %s\n", buf);
}
```

【代码详解】：

* 读取标准输入的数据
* 写入 `myfifo1`，send 进程负责发送
* 从 `myfifo2` 读取数据，实现双向通信
* 循环保证持续发送和接收

---

##### Step 4：关闭 FIFO（程序退出前可选）

```c
close(fd_w);
close(fd_r);
```

【代码详解】：

* 关闭文件描述符，释放资源
* FIFO 文件仍然存在于文件系统中

---

#### 3.2 FIFO 通信接收端（recv 进程）
（源码请见OS\RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\14_fifo_recv.c）

#### （1）实验目的

* 学习通过 FIFO 实现双向通信的接收端
* 掌握打开 FIFO 读写端的方法
* 理解读端阻塞和顺序约定

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
if (mkfifo("myfifo1", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}

if (mkfifo("myfifo2", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* `myfifo1` 用于接收 send 端发送的数据
* `myfifo2` 用于向 send 端发送回显
* `0664` 设置文件权限
* `errno == EEXIST` 表示 FIFO 已存在，直接使用即可

---

##### Step 2：打开 FIFO 文件描述符

```c
int fd_r, fd_w;

// 打开读端
if ((fd_r = open("myfifo1", O_RDONLY)) == -1)
{
    perror("fail to open myfifo1");
    exit(1);
}

// 打开写端
if ((fd_w = open("myfifo2", O_WRONLY)) == -1)
{
    perror("fail to open myfifo2");
    exit(1);
}
```

【代码详解】：

* `fd_r` 对应 `myfifo1`，从 send 端读取数据
* `fd_w` 对应 `myfifo2`，向 send 端写入回显
* `O_RDONLY` / `O_WRONLY` 分别表示只读和只写
* 打开顺序保证阻塞和同步

---

##### Step 3：循环读写数据

```c
char buf[128] = "";
ssize_t bytes;

while (1)
{
    // 从 send 端读取数据
    if ((bytes = read(fd_r, buf, sizeof(buf))) == -1)
    {
        perror("fail to read");
        exit(1);
    }
    printf("from send: %s\n", buf);

    // 从标准输入获取数据
    fgets(buf, sizeof(buf), stdin);
    buf[strlen(buf) - 1] = '\0';   // 去掉换行符

    // 写入到 send 端
    write(fd_w, buf, sizeof(buf));
}
```

【代码详解】：

* `read(fd_r, ...)` 从 send 端读取数据，阻塞直到有数据
* `printf` 输出接收到的数据
* `fgets` 从用户输入获取回显信息
* `write(fd_w, ...)` 将数据发送回 send 端
* 循环保证通信持续进行

---

##### Step 4：关闭 FIFO（可选）

```c
close(fd_r);
close(fd_w);
```

【代码详解】：

* 关闭文件描述符释放资源
* FIFO 文件仍然存在于文件系统中
---

### 任务四：有名管道的读写规律（阻塞）

#### 4.1 读写端都存在，只读不写
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\15_fifo_block_read_only.c）

#### （1）实验目的

* 观察在 FIFO 读写端都存在时，只进行读操作的阻塞行为
* 理解阻塞读模型：当管道中无数据时，`read()` 会等待数据
* 验证数据从 FIFO 中读取后即被移除，不会再次读取

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
if (mkfifo("myfifo", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* `mkfifo("myfifo", 0664)` 创建有名管道
* 文件权限 `0664` 允许所有者读写、组读写、其他用户只读
* 如果 FIFO 已存在 (`errno == EEXIST`)，直接使用无需退出

---

##### Step 2：打开 FIFO 文件描述符

```c
int fd;
if ((fd = open("myfifo", O_RDWR)) == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* 以 `O_RDWR` 打开 FIFO，保证读写端都存在
* 返回值 `fd` 为文件描述符，用于后续 `read` 和 `write` 操作
* `O_RDWR` 可以避免单端阻塞问题（如果只读而没有写端，打开可能阻塞）

---

##### Step 3：向 FIFO 写入数据

```c
write(fd, "hello world", 11);
```

【代码详解】：

* 写入 `"hello world"` 到 FIFO
* 为后续读操作提供数据
* 在本实验中写入后立即读取，模拟“只读端阻塞”情况

---

##### Step 4：循环读取数据

```c
char buf[128] = "";

read(fd, buf, sizeof(buf));
printf("buf = %s\n", buf);

read(fd, buf, sizeof(buf));
printf("buf = %s\n", buf);
```

【代码详解】：

* 第一次 `read(fd, buf, sizeof(buf))` 读取 FIFO 中数据 `"hello world"`
* 第二次 `read` 调用时，FIFO 中没有数据，如果没有写入端写入数据，会阻塞
* 数据从 FIFO 中读取后即被移除，不会重复出现

---

#### 4.2 读写端都存在，只写不读
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\16_fifo_block_write_only.c）

#### （1）实验目的

* 验证 FIFO 缓冲区写满时 `write()` 的阻塞行为
* 理解阻塞写模型：当管道缓冲区已满，写操作会等待读端读取数据
* 观察 FIFO 的流量控制机制

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
if (mkfifo("myfifo", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* 使用 `mkfifo("myfifo", 0664)` 创建有名管道
* 权限 `0664`：所有者可读写，组可读写，其他用户可读
* 如果 FIFO 已存在 (`errno == EEXIST`)，直接使用，不报错退出

---

##### Step 2：打开 FIFO 文件描述符

```c
int fd;
if ((fd = open("myfifo", O_RDWR)) == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* 以 `O_RDWR` 打开 FIFO，保证读写端都存在
* 返回值 `fd` 用于后续 `write()` 操作
* `O_RDWR` 防止只写而无读端导致的阻塞打开

---

##### Step 3：持续写入数据

```c
int num = 0;
while (1)
{
    write(fd, "", 1024);
    num++;
    printf("num = %d\n", num);
}
```

【代码详解】：

* 循环写入空数据 `""` 1024 字节到 FIFO
* `num` 用于记录写入次数，便于观察写操作何时阻塞
* 当 FIFO 缓冲区满时，`write()` 调用会阻塞，直到读端读取数据释放空间

---

#### 4.3 在一个进程中只有读端，没有写端
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\17_fifo_only_read.c）

#### （1）实验目的

* 观察 FIFO 在只有读端存在时的阻塞情况
* 理解阻塞打开模型：若没有写端，打开 FIFO 的读端会阻塞
* 掌握有名管道在单端存在时的行为特性

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
if (mkfifo("myfifo", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* 使用 `mkfifo("myfifo", 0664)` 创建有名管道
* 权限 `0664`：所有者可读写，组可读写，其他用户可读
* 如果 FIFO 已存在 (`errno == EEXIST`)，直接使用，不报错退出

---

##### Step 2：打开 FIFO 的读端

```c
int fd;
if ((fd = open("myfifo", O_RDONLY)) == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* 只打开读端 `O_RDONLY`
* 由于当前没有任何写端存在，`open()` 调用会阻塞，直到有进程打开写端
* 这体现了 FIFO 的阻塞打开特性

---

##### Step 3：循环读取数据

```c
char buf[128] = "";
ssize_t bytes;

while (1)
{
    if ((bytes = read(fd, buf, sizeof(buf))) == -1)
    {
        perror("fail to read");
        exit(1);
    }

    printf("bytes = %ld\n", bytes);
    printf("buf = %s\n", buf);
}
```

【代码详解】：

* `read()` 从 FIFO 中读取数据
* 如果写端关闭且管道为空，`read()` 返回 0（表示 EOF）
* 若写端存在但暂未写入数据，`read()` 阻塞等待数据
* `bytes` 显示实际读取的字节数

---

#### 4.4 在一个进程中只有写端，没有读端
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\18_fifo_only_write.c）

#### （1）实验目的

* 观察 FIFO 在只有写端存在时的阻塞行为
* 理解阻塞打开模型：若没有读端，打开 FIFO 的写端会阻塞
* 掌握 FIFO 在单端存在时的通信特性

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
if (mkfifo("myfifo", 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* 使用 `mkfifo("myfifo", 0664)` 创建有名管道
* 权限 `0664`：所有者可读写，组可读写，其他用户可读
* 如果 FIFO 已存在 (`errno == EEXIST`)，直接使用，不报错退出

---

##### Step 2：打开 FIFO 的写端

```c
int fd;
if ((fd = open("myfifo", O_WRONLY)) == -1)
{
    perror("fail to open");
    exit(1);
}
```

【代码详解】：

* 只打开写端 `O_WRONLY`
* 如果当前没有任何读端进程，`open()` 阻塞，直到有读端打开
* 阻塞机制防止写入无人接收的数据

---

##### Step 3：循环写入数据

```c
while (1)
{
    write(fd, "hello world", 11);
    printf("666\n");
}
```

【代码详解】：

* 使用 `write()` 将数据写入 FIFO
* 若缓冲区满且读端不及时读取，写操作会阻塞
* `printf("666\n")` 用于观察循环执行状态

---

#### 4.5 一个进程只读，一个进程只写

将上面4.3和4.4两个代码一起运行，保证有名管道读写端都存在

规律：
- 只要保证有名管道的读写端都存在，不管是几个进程，都不会再open这阻塞了
- 如果一个进程只读，一个进程只写，都运行后，如果关闭写端，读端read会返回0
- 如果一个进程只读，一个进程只写，都运行后，如果关闭读端，写端会立即产生SIGPIPE信号，默认的处理方式是退出进程。

### 任务五：有名管道的读写规律（非阻塞）
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\19_fifo_nonblock_read.c；RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\110_fifo_nonblock_write.c）

#### （1）实验目的

* 理解非阻塞方式打开 FIFO 后的行为差异
* 掌握非阻塞读写的特性：

  * 非阻塞读：管道无数据时，`read()` 不阻塞，立即返回
  * 非阻塞写：无读端时，`write()` 失败并返回错误

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
#define FIFO_NAME "myfifo"

if (mkfifo(FIFO_NAME, 0664) == -1)
{
    if (errno != EEXIST)
    {
        perror("fail to mkfifo");
        exit(1);
    }
}
```

【代码详解】：

* `mkfifo()` 创建有名管道
* 权限 `0664`：所有者可读写，组可读写，其他用户可读
* 如果 FIFO 已存在，忽略 `EEXIST` 错误

---

##### Step 2：非阻塞方式打开 FIFO（读端）

```c
int fd = open(FIFO_NAME, O_RDONLY | O_NONBLOCK);
if (fd < 0)
{
    perror("open fifo");
    exit(1);
}
```

【代码详解】：

* 使用 `O_NONBLOCK` 标记，设置非阻塞
* 如果管道无数据，`read()` 不阻塞，立即返回 -1 并设置 `errno = EAGAIN`

---

##### Step 3：非阻塞读循环

```c
char buf[128];
while (1)
{
    memset(buf, 0, sizeof(buf));
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n > 0)
    {
        printf("read data: %s\n", buf);
    }
    else if (n == -1 && errno == EAGAIN)
    {
        printf("no data yet, continue...\n");
    }
    usleep(500000); // 0.5秒循环
}
```

【代码详解】：

* `read()` 有数据时正常读取
* 无数据时立即返回并打印提示信息
* 循环不断尝试读取，实现非阻塞轮询

---

##### Step 4：非阻塞方式打开 FIFO（写端）

```c
int fd = open(FIFO_NAME, O_WRONLY | O_NONBLOCK);
if (fd < 0)
{
    perror("open fifo (write)");
    exit(1);
}
```

【代码详解】：

* `O_WRONLY | O_NONBLOCK` 打开写端
* 如果没有读端，`open()` 不阻塞，而是立即失败，返回 -1

---

##### Step 5：非阻塞写循环

```c
char msg[128];
int count = 1;
while (1)
{
    sprintf(msg, "Message %d from writer\n", count++);
    ssize_t n = write(fd, msg, strlen(msg));
    if (n == -1)
    {
        if (errno == EAGAIN)
            printf("no reader, write failed\n");
        else
        {
            perror("write error");
            break;
        }
    }
    else
    {
        printf("written: %s", msg);
    }
    sleep(1);
}
```

【代码详解】：

* 每秒写一条消息
* 若无读端，`write()` 返回 -1 并打印提示
* 写成功时，打印已写入消息

---

#### （3）执行步骤

1. 打开两个终端
2. 先运行非阻塞读程序：

```
gcc fifo_nonblock_read.c -o fifo_read
./fifo_read
```

3. 再运行非阻塞写程序：

```
gcc fifo_nonblock_write.c -o fifo_write
./fifo_write
```

4. 观察终端输出：

   * 读端不断尝试读取数据，不阻塞
   * 写端在没有读端时直接失败，并打印 `no reader, write failed`

---

### 任务六：父子进程通过 FIFO 通信
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\111_fifo_fork_comm.c）

#### （1）实验目的

* 利用 FIFO（有名管道）实现父子进程间的数据传输
* 掌握父子进程通信的基本机制
* 理解 FIFO 的同步与阻塞特性

---

#### （2）实验步骤

##### Step 1：创建 FIFO 文件

```c
char *FIFO = "myfifo";
unlink(FIFO);          // 删除已有的同名 FIFO
mkfifo(FIFO, 0666);    // 创建新的有名管道，权限可读写
```

【代码详解】：

* `unlink(FIFO)`：删除已有同名 FIFO，避免 `mkfifo()` 失败
* `mkfifo(FIFO, 0666)`：创建有名管道

  * 权限 `0666`：所有用户可读写
  * FIFO 文件会在文件系统中生成，但数据存储在内核缓冲区

---

##### Step 2：创建子进程

```c
if (fork() > 0) {
    // 父进程
} else {
    // 子进程
}
```

【代码详解】：

* 使用 `fork()` 创建子进程
* 返回值 > 0：父进程
* 返回值 = 0：子进程
* 通过判断 `fork()` 返回值决定父子进程执行不同任务

---

##### Step 3：父进程写 FIFO

```c
char s[] = "hello!\n";
fd = open(FIFO, O_WRONLY);    // 打开写端
write(fd, s, sizeof(s));      // 写入数据
close(fd);                    // 关闭写端
```

【代码详解】：

* 打开 FIFO 写端，阻塞直到有读端存在
* `write()` 将数据写入 FIFO
* 写完关闭文件描述符，表示写入完成

---

##### Step 4：子进程读 FIFO

```c
fd = open(FIFO, O_RDONLY);   // 打开读端
read(fd, buffer, 80);        // 读取数据
printf("%s", buffer);        // 输出到屏幕
close(fd);                    // 关闭读端
```

【代码详解】：

* 打开 FIFO 读端
* `read()` 阻塞直到有数据可读
* 将读取到的数据打印
* 关闭读端文件描述符

---

### 任务七：多写进程、单读进程通信（PID 实验）
（源码请见RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\112_fifo_reader.c；RISCV-OS-Experiments-Guide\实验六：进程间通信与管道实验\src\113_fifo_writer_pid.c）

#### （1）实验目的

* 使用两个程序实现 FIFO 通信：

  * 一个程序创建 FIFO 并持续读取数据
  * 另一个程序每隔一段时间向 FIFO 写入自己的进程 PID
* 运行多个写进程和一个读进程，观察数据读取顺序和行为
* 验证多个写进程同时向 FIFO 写入数据时的进程安全性

---

#### （2）实验步骤

##### Step 1：创建 FIFO 并持续读取（读程序）

```c
// 删除可能存在的 FIFO 文件
unlink(FIFO_NAME);

// 创建新的 FIFO
if (mkfifo(FIFO_NAME, 0666) < 0) {
    perror("mkfifo");
    exit(1);
}

// 以只读方式打开 FIFO（会阻塞，直到有写端打开）
int fd = open(FIFO_NAME, O_RDONLY);
if (fd < 0) {
    perror("open");
    exit(1);
}

printf("读取程序启动：等待数据……\n");
```

【代码详解】：

* `unlink(FIFO_NAME)`：删除旧的 FIFO 文件
* `mkfifo(FIFO_NAME, 0666)`：创建新 FIFO，权限可读写
* `open(O_RDONLY)`：阻塞打开 FIFO 的读端
* 阻塞直到至少有一个写端存在

---

##### Step 2：循环读取 FIFO 数据

```c
while (1) {
    char buf[128];
    ssize_t n = read(fd, buf, sizeof(buf)-1);
    if (n > 0) {
        buf[n] = '\0';
        printf("读程序：收到 %s", buf);
    } else if (n == 0) {
        printf("读程序：所有写端已关闭，退出。\n");
        break;
    } else {
        perror("read");
        break;
    }
}
```

【代码详解】：

* `read()` 从 FIFO 中读取数据
* `n > 0`：成功读取数据，打印到屏幕
* `n == 0`：所有写端关闭，FIFO 到达 EOF
* `n == -1`：发生错误

---

##### Step 3：关闭 FIFO 并清理

```c
close(fd);
unlink(FIFO_NAME); // 删除 FIFO 文件
```

【代码详解】：

* `close(fd)`：关闭读端文件描述符
* `unlink(FIFO_NAME)`：删除 FIFO 文件，释放资源

---

##### Step 4：写进程代码（每隔一秒写入 PID）

```c
// 打开 FIFO 写端（若无读端则阻塞）
int fd = open(FIFO_NAME, O_WRONLY);
if (fd < 0) {
    perror("open");
    exit(1);
}

pid_t pid = getpid();

// 每隔 1 秒写一次 PID
while (1) {
    char msg[128];
    sprintf(msg, "进程 %d 正在写入\n", pid);
    write(fd, msg, strlen(msg));
    sleep(1);
}

close(fd);
```

【代码详解】：

* `open(O_WRONLY)`：打开写端，如果没有读端则阻塞
* `sprintf()`：将 PID 格式化为字符串
* `write()`：写入 FIFO
* `sleep(1)`：控制写入间隔

---

#### （3）代码执行步骤

1. 编译读程序与写程序：

```
gcc fifo_reader.c -o fifo_reader
gcc fifo_writer.c -o fifo_writer
```

2. 先运行读程序：

```
./fifo_reader
```

3. 再运行多个写程序：

```
./fifo_writer
./fifo_writer
```

4. 观察终端输出：

* 读端按 FIFO 顺序读取各写进程的数据
* 验证多个写进程同时写入时数据的完整性和顺序
* 每条写入数据不会被破坏

---

## 四、观察与思考

1. FIFO 的阻塞行为对程序设计有哪些影响？
2. 多个写进程同时写 FIFO 是否会造成数据混乱？
3. 非阻塞方式下如何正确处理读写返回值？
4. FIFO 与消息队列相比有哪些优缺点？
5. 在实际系统中，FIFO 适合用于哪些通信场景？

---

## 五、实验小结

通过本节多个循序渐进的实验，系统掌握了有名管道 FIFO 的创建、读写及其在不同进程组合和阻塞条件下的行为特性。实验结果表明，FIFO 是一种简单而有效的进程间通信方式，适用于不相关进程之间的数据交换，为后续学习更复杂的 IPC 机制奠定了基础。
