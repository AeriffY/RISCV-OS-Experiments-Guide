# 进程隔离与二叉进程树

## 一、 进程隔离

在标准的 UNIX 进程模型中，`fork` 系统调用是创建新进程的主流方式。我们已经知道 `fork` 函数会产生一个新的子进程，该子进程复制父进程的数据与堆栈空间，并继承父进程的用户代码与环境上下文。然而，这种复制机制导致子进程与父进程处于同一个全局命名空间中，子进程能够通过 `ps` 命令或遍历 `/proc` 目录感知到系统中所有其他进程的存在。在安全需求高的场景下，这种操作显然是有明显安全隐患的。

Linux 内核通过 `clone` 系统调用解决了这一问题。虽然 `fork` 在底层实现上最终也会调用 `clone`，但它使用了一组固定的默认标志位，最终导致了资源的高度共享。`clone` 函数允许开发者通过精细定义的位掩码（Flags）来显式控制父子进程之间共享或隔离的资源类型，其基本形式为：

```c
int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...)
```

参数 `fn` 是一个函数指针，指向子进程启动后将要执行的代码入口点。这与 `fork` 后子进程直接从调用点下一条指令继续执行的逻辑截然不同。当 `fn` 函数返回时，子进程将自动终止，其返回值即为子进程的退出状态码。参数 `arg` 则是传递给 `fn` 函数的唯一参数，通常用于传递上下文数据结构的指针。

参数 `stack` 是 `clone` 函数最为显著的特征之一。由于 `clone` 允许创建与父进程共享地址空间的轻量级进程（即线程），内核无法像 `fork` 那样简单地复制父进程的栈空间，因为共享地址空间的两个执行流若共用同一个栈，将会导致严重的栈帧覆盖与数据竞争。因此，调用者必须在用户空间显式分配一块内存区域（通常使用 `malloc` 或 `mmap`），并将指向该区域高地址或低地址的指针传递给 `clone`，作为子进程的独立栈空间。

`clone` 函数的核心威力在于其第三个参数 `flags`。这是一个整型位掩码，通过不同标志位的逻辑或运算，决定了新创建的执行单元与父进程之间的资源关系。

`CLONE_VM` 标志位控制虚拟内存空间的共享。当设置此标志时，调用进程与子进程运行在同一个虚拟地址空间中。这意味着其中一方对内存数据的写入（包括堆、数据段等）将立即对另一方可见。这正是 POSIX 线程库创建线程时的底层实现基础，使得多个执行流能够高效地协作处理共享数据。若未设置此标志，子进程将获得父进程地址空间的副本，行为类似于 `fork`。

`CLONE_FILES` 与 `CLONE_FS` 标志位分别控制文件描述符表与文件系统信息的共享。设置 `CLONE_FILES` 后，父子进程共享同一张打开文件表，一方关闭或移动文件指针的操作会影响另一方。`CLONE_FS` 则涉及当前工作目录与根目录的共享。这些标志位使得构建复杂的 I/O 处理模型成为可能。

`CLONE_SIGHAND` 与 `CLONE_THREAD` 标志位用于实现线程组的概念。在 Linux 内核中，同一个线程组内的所有线程拥有唯一的进程 ID（TGID），但拥有各自独立的线程 ID（TID）。通过设置这些标志，`clone` 创建的执行单元在内核眼中成为父进程所在线程组的一员，能够响应发送给该组的信号，这符合 POSIX 线程标准对信号处理的要求。

除了控制资源共享，`flags` 参数还引入了一系列以 `CLONE_NEW` 开头的标志位，用于构建隔离的命名空间。这是现代容器技术的基石。

`CLONE_NEWPID` 标志位创建一个新的 PID 命名空间。在此空间中创建的第一个进程将被内核赋予 PID 1，成为该空间的初始化进程，负责回收孤儿进程并管理生命周期，且无法感知宿主机命名空间中的其他进程。`CLONE_NEWNS` 标志位允许子进程拥有独立的文件系统挂载点视图，子进程执行的挂载或卸载操作不会影响宿主机，从而实现了文件系统的隔离，需要特别注意的是，该标志位的命名不准确，实际上指的是 Mount Namespace。

此外，`CLONE_NEWNET`、`CLONE_NEWIPC` 和 `CLONE_NEWUTS` 分别用于隔离网络栈、进程间通信设施以及主机名信息。通过组合这些标志位，`clone` 函数能够在共享同一个内核的前提下，为应用程序构建出一个在视图上完全独立的运行环境。使用过 Docker 的同学应该会对这些机制特别熟悉。



在实验的第一部分里，我们需要编写一个 C 语言程序以验证 PID 隔离机制。该程序需要引入 `<sched.h>` 头文件，并分配一块独立的内存区域作为子进程的栈空间。在调用 `clone` 函数时，必须将 `CLONE_NEWPID` 与 `SIGCHLD` 标志进行按位或运算后传入。子进程的执行函数应当调用 `getpid` 获取自身的 PID 并打印至标准输出，同时父进程也应打印其视角下子进程的 PID。

预期的实验现象应当展示出内核视图与用户视图的显著差异。在父进程所在的宿主机命名空间中，`clone` 调用将返回一个常规的、递增的 PID，表明该子进程在全局调度队列中依然是一个普通的受管对象。然而，在子进程的隔离视角中，`getpid` 将返回 1。

PID 1 在 Linux 系统中具有特殊的语义，因为该进程号通常是被保留给 init 进程的。而这意味着该子进程在其所在的命名空间中承担了初始化进程的角色，拥有了回收孤儿进程等特权，且无法感知宿主机命名空间中的任何其他进程。由此，我们可以得知容器技术是如何通过欺骗进程的感知来实现环境隔离的。

参考示例：`./src/进程管理/pid_isolation.c`

## 二、 二叉树

Linux 内核通过父进程标识符（PPID）维护着严格的进程家族谱系 3。这种树状结构是操作系统管理进程生命周期、传递信号以及回收资源的基础。在前序实验中，实验者已通过 `pstree` 命令观察过现有的系统进程树。本实验的第二部分要求实验者从被动的观察者转变为主动的构建者，通过算法精确控制进程的生成逻辑，在内核中构建一个特定几何形状的进程拓扑。



在第二部分实验中，我们需要编写一个能够生成二叉树结构进程组的 C 语言程序。该程序需接收一个整数参数作为树的深度限制。程序的执行逻辑应采用递归算法：当当前深度小于最大深度时，当前进程（父节点）将连续调用两次 `fork`。第一次 `fork` 生成左子节点，第二次 `fork` 生成右子节点。每个新生成的子进程将继承当前的深度计数器并加一，随后递归调用相同的逻辑。

为了确保进程树在观测期间保持完整的形态，所有节点进程在完成生成任务后，必须执行长周期的 `sleep` 操作或进入暂停状态（`pause`），防止进程过早退出导致拓扑结构断裂。在程序运行期间，实验者需开启另一个终端窗口，利用 `pstree -p [根进程PID]` 指令对生成的进程组进行快照观测。

实验成功的标志是 `pstree` 的输出能够清晰地呈现出一个节点完备、层次分明的二叉树结构，且每个节点均标记有独立的 PID。

参考示例：`./src/进程管理/process_tree.c`