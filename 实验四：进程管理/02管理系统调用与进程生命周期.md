# 系统调用与进程生命周期管理

Linux 遵循 POSIX 标准，提供了一套 C 语言系统调用库用于精细控制进程行为。本节实验旨在指导实验者通过编写 C 语言程序，直接调用内核函数以实现进程的创建、执行新程序、属性获取以及父子进程间的同步与通信。

## 一、 进程身份标识与权限控制原理

在 Linux 内核的数据结构中，每个进程均被赋予了一组唯一的标识符，用于界定其身份与权限边界。最基础的标识符为进程 ID（PID），系统保证在同一时刻 PID 的唯一性。通过调用 `getpid()` 函数，进程可以获取自身的 ID，而 `getppid()` 则用于获取创建当前进程的父进程 ID。

进程的权限控制机制更为复杂，分为“真实 ID”与“有效 ID”。真实用户 ID（Real UID, `uid`）标识了启动该进程的用户身份，由 `getuid()` 获取；而有效用户 ID（Effective UID, `euid`）则决定了进程在执行过程中对文件系统资源的实际访问权限，由 `geteuid()` 获取。通常情况下，两者是相同的。然而，当可执行文件设置了 Set-UID 位时，进程在执行时的有效用户 ID 将变更为该文件所有者的 UID，而非启动者的 UID。这一机制是 `passwd` 等需要临时提升权限的命令得以实现的底层原理。同理，组 ID 也分为真实组 ID（GID）与有效组 ID（EGID），分别通过 `getgid()` 和 `getegid()` 获取，用于控制基于组的资源访问权限。



## 二、 进程复制机制

Linux 系统中创建新进程的核心机制是 `fork()` 系统调用。当父进程调用 `fork()` 时，内核会创建一个新的子进程。该子进程几乎完整复制了父进程的内存映像，包括数据段、堆栈空间、用户代码、环境变量以及打开的文件描述符。然而，为了提高效率，Linux 采用了“写时复制”（Copy-On-Write, COW）技术。在 `fork()` 调用之初，父子进程共享相同的物理内存页，只有当其中一方试图修改内存数据时，内核才会真正复制该内存页给修改者。

`fork()` 函数具有独特的“一次调用，两次返回”特性。在父进程中，该函数返回新创建子进程的 PID；而在子进程中，该函数返回 0。若返回值为 -1，则表示创建失败，通常源于内存不足等原因。

需要注意的是，虽然子进程继承了大部分属性，但它不会继承父进程的文件记录锁以及未处理的信号集，且 Linux 不保证父子进程的执行顺序，这要求程序员必须防范竞态条件（Race Condition）的发生。



## 三、 程序执行映像的替换

`fork()` 仅能产生父进程的副本，若要执行全新的程序，必须使用 `exec` 函数族。该系列函数（包括 `execl`, `execlp`, `execv`, `execve` 等）会用指定的可执行文件加载并替换当前进程的地址空间，包括代码段、数据段和堆栈。一旦 `exec` 调用成功，当前进程的代码将被新程序覆盖，并从新程序的 `main` 函数开始执行，因此原程序中 `exec` 之后的代码将永远不会被执行，除非 `exec` 调用失败返回 -1。

`exec` 函数族的主要区别在于参数传递方式与文件查找策略：后缀 `l` 表示参数以列表（List）形式逐个传递，需以 NULL 结尾；后缀 `v` 表示参数以向量（Vector）形式传递；后缀 `p` 表示在系统的 `PATH` 环境变量指定的目录中查找可执行文件；后缀 `e` 则允许调用者为新进程指定自定义的环境变量数组。例如，`execlp("ls", "ls", "-al", NULL)` 会自动在路径中寻找 `ls` 命令并执行。



## 四、 进程同步与资源回收

父子进程间的同步通过 `wait()` 与 `waitpid()` 系统调用实现。当子进程结束运行（无论是正常退出还是被信号终止）时，内核会保留其部分信息（如退出状态码、CPU 时间统计等），此时子进程进入“僵尸态”（Zombie State）。父进程必须调用 `wait()` 来读取这些信息并释放子进程占用的系统表项。

`wait()` 函数会挂起父进程的执行，直到任意一个子进程结束。若需等待特定的子进程，则应使用 `waitpid()`，该函数允许指定 PID，并可通过 `options` 参数实现非阻塞等待。子进程的退出状态通过 `status` 指针返回，父进程需使用宏来解析该状态值，如使用 `WIFEXITED` 判断进程是否正常退出，`WEXITSTATUS` 获取进程的退出码等等。若父进程在子进程结束前退出，子进程将成为“孤儿进程”，由 `init` 进程接管并负责回收。



## 五、 实验内容：进程控制编程实践

请编写并运行以下 C 语言程序，以验证上述原理。

### 1. 分析进程身份及权限

编写一个程序，分别调用 `getpid`, `getppid`, `getuid`, `geteuid`, `getgid`, `getegid` 函数，并将结果打印至标准输出。实验者需分析真实用户 ID 与有效用户 ID 的区别，并通过 `chmod u+s` 指令修改可执行文件的 Set-UID 位，随后观察程序运行结果的变化。

参考示例 `./src/进程管理/process_identity.c` 

### 2. 多进程并发

编写程序创建子进程，在父子进程的分支中分别打印各自的 PID 与 PPID。多次运行该程序，观察终端输出中“in child”与“in parent”字符串出现的先后顺序，分析 Linux 进程调度策略对并发执行顺序的不确定性影响，并总结 PID 的分配规律。

参考示例 `./src/进程管理/fork usage.c` 

### 3. 进程间通信

编写一个包含信号处理机制的程序。父进程需创建两个子进程，并利用 `sleep()` 函数控制执行节奏。父进程随后通过 `kill()` 系统调用向子进程发送特定信号，子进程需利用 `signal()` 函数注册自定义的信号处理函数 `stop()` 来响应这些信号。观察并记录进程是如何响应信号并终止的，进而理解软中断机制在进程控制中的作用。

参考示例 `./src/进程管理/usage of kill,signal,wait.c` 

### 4. 进程时间统计

利用 `times()` 系统调用编写程序，测量执行一段 shell 命令所消耗的用户 CPU 时间与系统 CPU 时间。一般来说，如 `grep` 这类命令消耗的时间是非常少的。随后编写一个计算密集型程序，对比二者在 CPU 时间消耗分布上的差异。

参考示例 `./src/进程管理/cpu_time_analysis.c` 