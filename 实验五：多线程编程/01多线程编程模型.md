# 实验六：多线程编程模型

在先前的实验中，我们探讨了基于 `fork` 系统调用的多进程模型。`fork` 函数会产生一个新的子进程，该子进程复制父进程的数据与堆栈空间。尽管写时复制（Copy-On-Write）技术优化了这一过程，但进程间独立的内存空间仍然使得数据交换依赖于管道、消息队列等机制，且上下文切换开销较大。

为了解决高并发场景下的资源消耗与通信效率问题，操作系统引入了线程（Thread）概念。线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。在 Linux 系统中，线程通常基于 POSIX Threads (pthreads) 标准库实现，它的底层仍然依赖于 `clone` 系统调用。但与进程不同的是，线程通过共享虚拟内存空间（包括代码段、数据段、堆）来实现轻量级的特性。

## 一、 线程的创建与内存可见性验证

本实验的首要任务是验证线程与进程在内存隔离性上的本质区别。实验者需要编写一个基于 `<pthread.h>` 库的 C 语言程序。该程序首先定义一个全局整型变量，初始值设为 0。随后在 `main` 函数中，利用 `pthread_create` 函数创建一个新线程，随后在子线程的执行函数中，程序应对该全局变量进行修改操作（例如将其赋值为 100），并打印该变量的内存地址与当前数值。与此同时，主线程在调用 `pthread_create` 后，需利用 `pthread_join` 函数阻塞等待子线程结束。待子线程退出后，主线程再次读取并打印同一全局变量的地址与数值。

预期实验结果将显示，主线程与子线程打印出的变量内存地址完全一致，且主线程能够直接读取到子线程对变量的修改结果。这与 `fork` 创建的子进程形成鲜明对比。在 `fork` 模型中，子进程对变量的修改发生在其独立的地址空间副本中，不会影响父进程。通过此实验，实验者将证实线程间共享同一进程地址空间的特性，这是高效数据交换的基础，同时也是并发安全问题的根源。



`pthread_create` 函数的原型为：

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)
```

可以看到，与 `fork` 返回 PID 不同，`pthread_create` 接受一个指向 `pthread_t` 类型变量的指针作为新线程的入口点，用于存储新创建线程的唯一标识符。

第二个参数用于设置线程属性（如栈大小、调度策略），在基础实验中，通常仅传递 `NULL`。第三个参数是新线程启动后执行的函数入口地址，该函数指针必须符合 `void *(*)(void *)` 的签名，意味着它接收一个通用指针参数并返回一个通用指针。第四个参数即为传递给启动函数的具体参数值。若创建成功，函数返回 0；否则返回错误码。值得注意的是，`pthread_create` 返回时，新线程可能已经开始执行，也可能仍在就绪队列中等待调度，程序设计必须考虑到这种执行顺序的不确定性。



`pthread_join` 函数的原型为：

```c
int pthread_join(pthread_t thread, void **retval)
```

该函数的功能类似于进程管理中的 `waitpid`。当调用 `pthread_join` 时，调用线程将进入阻塞状态，直到参数 `thread` 指定的目标线程终止。该机制不仅用于同步执行流，更是回收资源的关键步骤。若不执行 `join` 操作，已终止的线程将成为“僵尸线程”，其栈空间和描述符不会被系统释放。函数的第二个参数 `retval` 是一个双重指针，用于接收目标线程的退出状态或返回值。若无需获取返回值，可将其设为 `NULL`。



## 二、 竞态条件的复现

共享地址空间虽然提升了通信效率，但也引入了数据竞争风险。当多个执行流并发访问同一块内存区域，且至少有一个执行流进行写入操作时，如果缺少同步机制，执行结果将依赖于特定时刻的线程调度顺序，这种现象称为竞态条件（Race Condition）。

实验要求构建一个多线程计数器程序以复现此问题。程序需定义一个全局长整型变量 `counter`，初值为 0。主程序创建两个线程，每个线程的任务是在一个循环中对 `counter` 执行一百万次自增操作（`counter++`）。主线程等待两个子线程结束后，打印 `counter` 的最终值。

读者可能会以为，理论上，两个线程各增加一百万次，最终结果理所当然应为两百万。然而，实际运行结果往往显著小于该值。从汇编指令层面分析其原因可知，C 语言中的 `counter++` 并非原子操作，它对应着加载（Load）-修改（Increment）-存储（Store）三条机器指令。当线程 A 完成加载与修改但尚未存储时，若操作系统发生时钟中断并切换至线程 B，线程 B 将读取到旧的 `counter` 值。待线程 B 完成计算并写入后，线程 A 恢复执行并写入其计算结果，结果导致线程 B 的更新被覆盖，最终导致实际运行结果显著小于理论值。并发错误是编程中非常容易触发的陷阱，高级语言语句的非原子性与操作系统抢占式调度共同导致了这种错误。



## 三、 互斥锁与临界区保护

为了解决竞态条件，操作系统提供了同步原语来保障临界区的原子性。互斥锁（Mutex）是最基本的同步机制，它保证了同一时刻只有一个线程能进入临界区。

请对上述计数器程序进行改造。引入 `pthread_mutex_t` 类型定义的互斥锁变量，并在 `main` 函数中通过 `pthread_mutex_init` 进行初始化。在线程执行函数的循环体内，在执行 `counter++` 之前调用 `pthread_mutex_lock`，在自增操作完成后立即调用 `pthread_mutex_unlock`。

改造后的程序在运行时，当线程 A 持有锁时，试图获取该锁的线程 B 将被内核挂起并置于阻塞队列中，直到线程 A 释放锁。这强制将并发执行的自增操作串行化。实验者需重新编译运行程序，确认最终结果稳定为两百万，验证数据一致性得以恢复。同时，实验者应观察加锁版本与无锁版本在运行时间上的差异，分析因频繁的锁竞争与上下文切换带来的性能损耗，从而理解并发编程中正确性与性能之间的权衡。



`pthread_mutex_init` 的原型为：

```c
pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
```

该函数将参数 `mutex` 指向的锁变量初始化为未锁定状态。第二个参数 `attr` 用于指定互斥锁的属性（如递归锁、错误检查锁等），一般传递 `NULL` 即可使用默认的快速互斥锁属性。对于静态分配的全局互斥锁，也可以直接使用宏 `PTHREAD_MUTEX_INITIALIZER` 进行初始化，从而省去函数调用的开销。



`pthread_mutex_lock` 的原型为：

```c
int pthread_mutex_lock(pthread_mutex_t *mutex)
```

该函数的行为具有原子性：若当前互斥锁处于未锁定状态，调用线程将立即获得该锁并将其置为锁定状态，函数成功返回；若互斥锁已被其他线程占用，调用线程将被挂起并放入等待队列，进入阻塞状态，直到该锁被持有者释放。这种阻塞机制避免了自旋等待带来的 CPU 资源浪费。



`pthread_mutex_unlock` 的原型为：

```c
int pthread_mutex_unlock(pthread_mutex_t *mutex)
```

该函数将互斥锁重置为未锁定状态，并尝试唤醒在等待队列中阻塞的一个或多个线程。严谨的编程规范要求 `lock` 与 `unlock` 操作必须在同一个线程的同一逻辑层级中成对出现，且必须严格覆盖所有可能的代码路径，包括异常处理分支，以防止因遗漏释放操作而导致的死锁现象。