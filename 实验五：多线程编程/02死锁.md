# 死锁的成因与避免

在并发程序设计中，互斥锁虽然有效地解决了竞态条件，保障了数据的一致性，但其引入的资源独占特性也带来了新的风险——死锁。死锁是指两个或两个以上的执行单元在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉，这些执行单元都将无法推进。

## 一、 死锁产生的理论模型

从操作系统原理的角度分析，死锁的发生有四个必要条件。首先是互斥条件，即资源是独占的，同一时刻只能由一个线程持有；其次是占有且等待条件，即线程在持有至少一个资源的同时，又申请新的资源，而新资源被其他线程占有；第三是不可抢占条件，即资源只能由持有者主动释放，不能被强制剥夺；一般来说，满足前三个条件，便能触发死锁。最后是循环等待条件，即存在一个线程集合 $\{T_1, T_2, ..., T_n\}$，其中 $T_1$ 等待 $T_2$ 占有的资源，$T_2$ 等待 $T_3$ 占有的资源，以此类推，直至 $T_n$ 等待 $T_1$ 占有的资源，形成闭环。仅满足循环等待条件也能发生死锁。

## 二、 构建死锁

为了复现最经典的死锁现象，实验要求构建一个双线程、双锁资源的程序模型。实验者需定义两个全局互斥锁变量，分别命名为 `mutex_A` 和 `mutex_B`，并完成初始化。同时，创建两个子线程，分别命名为 `Thread_1` 和 `Thread_2`。

在 `Thread_1` 的执行逻辑中，设计如下操作序列：首先调用 `pthread_mutex_lock(&mutex_A)` 获取锁 A 的所有权；紧接着，为了确保线程调度器发生切换，强制执行 `sleep(1)`，使线程主动放弃 CPU 时间片；苏醒后，尝试调用 `pthread_mutex_lock(&mutex_B)` 获取锁 B。若成功获取双锁，则打印“Thread 1 获得双锁”，最后依次释放锁 B 和锁 A。

在 `Thread_2` 的执行逻辑中，采用对称但相反的加锁顺序：首先调用 `pthread_mutex_lock(&mutex_B)` 获取锁 B 的所有权；同样执行 `sleep(1)` 以暂停执行；苏醒后，尝试调用 `pthread_mutex_lock(&mutex_A)` 获取锁 A。若成功，打印相应信息并依次释放锁 A 和锁 B。

当实验者编译并运行该程序时，预期的实验现象是：程序启动后约一秒钟，两个线程均陷入永久的静默状态，终端没有任何输出，且程序不会自动退出。此时，系统发生了死锁。这是因为在 `sleep` 期间，`Thread_1` 持有 A 且等待 B，而 `Thread_2` 持有 B 且等待 A。由于 `pthread_mutex_lock` 是阻塞式调用，双方均在等待对方释放资源，从而形成了逻辑上的死结。实验者可利用 `top` 或 `ps` 命令查看该进程状态，通常显示为 `S`（睡眠）或 `Dl`（不可中断睡眠），表明其处于挂起等待状态。

## 三、 死锁的诊断与分析

在程序陷入停滞后，实验者需掌握基本的诊断手段。Linux 环境下提供了 `pstack`（或 `gdb`）工具用于查看进程的调用堆栈。可以在另一个终端执行 `pstack [PID]`。输出的堆栈信息将显示两个线程均阻塞在 `__lll_lock_wait` 或类似的内核函数上。这一证据直接表明了线程正在等待锁资源，证实了死锁的存在。

通过分析代码逻辑，实验者应确认该场景满足了上述四个必要条件：互斥锁保证了互斥性；`sleep` 后的申请操作构成了占有且等待；锁的 API 特性决定了不可抢占；而相反的加锁顺序（A->B 与 B->A）则直接导致了循环等待。

## 四、 死锁解除

解决死锁的根本策略在于破坏四个必要条件中的任意一个。其中，破坏“循环等待”条件是最为可行且通用的工程方法。该策略要求对系统中的所有互斥资源进行统一编号或排序，规定所有线程必须按照相同的顺序申请资源。

实验者可修改上述程序的代码，实施“资源有序分配”策略。具体做法是：保持 `Thread_1` 的加锁顺序不变（先 A 后 B），将 `Thread_2` 的加锁顺序调整为与 `Thread_1` 一致，即同样先调用 `pthread_mutex_lock(&mutex_A)`，再调用 `pthread_mutex_lock(&mutex_B)`。

修改后的执行流程分析如下：当 `Thread_1` 率先获得锁 A 并进入休眠时，`Thread_2` 启动并尝试获取锁 A。由于锁 A 已被占用，`Thread_2` 将在第一步就被阻塞，无法继续获取锁 B。这有效地避免了 `Thread_2` 持有锁 B 的情况。当 `Thread_1` 苏醒后，它能顺利获得未被占用的锁 B，完成任务并释放两把锁。随后，`Thread_2` 被唤醒并依次获得锁 A 和锁 B。实验者重新编译运行修改后的程序，将观察到两个线程均能顺利完成打印任务并退出，证明循环等待链已被切断，死锁得以消除。

## 五、哲学家就餐问题

在理解了基于双线程的双资源死锁后，我们需要将视野扩展至更为通用的多进程并发场景。哲学家就餐问题是由艾兹格·迪杰斯特拉（Edsger Dijkstra）提出的经典同步问题，它精准地抽象了多个并发进程争夺有限数量共享资源的场景。在本实验中，我们将构建一个由五个线程构成的环形系统，分析在资源对称分布的情况下产生死锁的必然性，并探讨破坏循环等待条件或引入资源总量限制的解决方案。

### 一、 问题模型的抽象

该问题的物理模型由五个并发执行的线程（代表哲学家）和五把互斥锁（代表筷子）组成。线程与锁呈环形交替排列，即线程 $P_i$ 的左侧是锁 $L_i$，右侧是锁 $L_{(i+1)\%5}$。根据规则，任何一个线程在执行关键任务（进餐）前，必须同时持有其左右两侧的锁。若无法同时获取，线程需等待。

实验的第一阶段要求编写一个模拟该死锁场景的 C 语言程序。实验者需定义一个包含五个 `pthread_mutex_t` 元素的全局数组，并初始化为未锁定状态。随后创建五个线程，每个线程执行相同的逻辑函数：首先调用 `pthread_mutex_lock` 获取左侧的锁（索引为 $i$），为了放大死锁发生的概率，在获取第一把锁后强制执行 `usleep` 或 `sleep` 操作以触发调度切换，随后尝试获取右侧的锁（索引为 $(i+1)\%5$）。

当程序运行后，由于所有线程执行完全对称的逻辑，系统将极大概率进入死锁状态。此时，五个线程各自持有了其左侧的锁，并同时被阻塞在获取右侧锁的请求上。这构成了一个环形等待链。

实验者可自行思考如何解决死锁问题。

### 二、 基于资源分级的解法

解决环形死锁的核心在于破坏循环等待条件。资源分级策略（或称非对称策略）是一种极其有效的工程化手段。该策略规定系统中的所有资源必须赋予一个全局唯一的序号，所有进程申请资源时必须严格按照序号递增（或递减）的顺序进行。

实验的第二阶段要求修改上述代码以打破对称性。具体算法逻辑如下：对于编号为 0 至 3 的线程（即前四个哲学家），保持原有的“先左后右”策略，即先申请低序号锁 $i$，再申请高序号锁 $i+1$。然而，对于编号为 4 的线程（最后一个哲学家），强制改变其加锁顺序，要求其先申请右侧的锁（序号为 0，即低序号），再申请左侧的锁（序号为 4，即高序号）。

通过这一简单的逻辑调整，环形依赖被彻底切断。分析可知，当线程 4 试图获取锁 0 时，若锁 0 已被线程 0 持有，线程 4 将阻塞在第一步，从而无法获取锁 4。这使得锁 4 保持空闲状态，进而允许线程 3 顺利获取其所需的两把锁并完成任务。随着线程 3 的释放，资源将沿着环路反向依次释放。实验者需运行修改后的程序，验证在长时间运行下系统依然能够保持高吞吐量且不再发生死锁。

### 三、 基于信号量的并发限制解法

除了控制加锁顺序外，通过限制并发度来破坏占有且等待条件也是一种常见的解决方案。若系统强制规定同一时刻最多允许四个线程参与资源竞争，则必然存在至少一个线程能够同时获得两把锁，从而保证系统的推进。

实验的第三阶段要求引入 `<semaphore.h>` 库，定义一个初始值为 4 的计数信号量 `sem_t count`。在线程尝试获取任何互斥锁之前，必须先调用 `sem_wait(&count)` 申请一个许可；在线程释放两把锁并结束进餐后，调用 `sem_post(&count)` 归还许可。

实际上，当有五个资源（筷子）和最多四个请求者时，无论请求者如何分配资源，必然有一个请求者能够获得两个资源。实验者可以对比该方案与资源分级方案在代码复杂度和运行效率上的差异。



实验者可自行思考是否有更多解法。