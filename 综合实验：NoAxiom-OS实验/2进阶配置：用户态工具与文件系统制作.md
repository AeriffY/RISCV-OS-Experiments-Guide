# 进阶配置：用户态工具与文件系统制作

在完成基础内核编译后，运行 `make run` 往往会遇到 `busybox not found in bin` 或无法找到测试用例的错误。这是因为项目的自动化构建脚本并未涵盖所有用户态组件。本章节将带领你从问题诊断开始，手动构建并注入一个完整的用户态执行环境。

## 一、 问题诊断：为什么缺少 Busybox？

在尝试运行前，我们先通过 Makefile 的帮助信息确认构建逻辑：

1. **执行帮助命令**
   ```bash
   make help
   ```
2. **分析输出**
   输出显示 `run: run the kernel in QEMU without build`。这意味着 `make run` 目标仅负责启动模拟器，并不会自动构建用户态程序（user）、生成根文件系统（rootfs）或下载 Busybox。因此，镜像中缺少这些关键的二进制文件，导致系统启动后无法进入 Shell。

---

## 二、 交叉编译静态 Busybox (RISC-V)

普通的交叉编译可能生成 `DYN (Shared object file)` 类型的二进制文件，这在某些简易内核中无法执行。我们需要确保生成的是 **EXEC (Executable file)**。

1. **准备 musl 交叉编译工具链**
   使用 musl 工具链可以更方便地生成不依赖动态库的二进制文件。
   ```bash
   cd /root/
   wget https://musl.cc/riscv64-linux-musl-cross.tgz
   tar -xf riscv64-linux-musl-cross.tgz
   export PATH=$PATH:/root/riscv64-linux-musl-cross/bin
   ```

2. **获取并配置 Busybox 源码**
   ```bash
   git clone https://git.busybox.net/busybox
   cd busybox
   make CROSS_COMPILE=riscv64-linux-musl- defconfig
   ```

3. **开启静态链接（关键步骤）**
   执行 `make menuconfig`，在弹出的菜单中进入 `Settings`，找到 `Build static binary (no shared libs)` 并勾选（按空格键使其显示为 `[*]`），保存并退出。

4. **指定非 PIE 参数编译**
   为了生成 `EXEC` 格式而非 `DYN` 格式，编译时需禁用位置无关代码：
   ```bash
   make CROSS_COMPILE=riscv64-linux-musl- \
        CFLAGS="-fno-PIE -no-pie" \
        LDFLAGS="-static -no-pie" -j$(nproc)
   ```
   *编译完成后，使用 `file busybox` 确认输出为 `statically linked`，使用 `readelf -h busybox` 确认类型为 `EXEC`。*

---

## 三、 制作根文件系统镜像

由于在某些环境下直接 `mount` 挂载文件需要 root 权限且容易出错，我们使用 `mtools` 工具在用户态直接操作镜像。

1. **安装必要工具**
   ```bash
   apt-get update && apt-get install -y dosfstools mtools
   ```

2. **优化镜像构建脚本**
   进入 `NoAxiom-OS/NoAxiom-OS-Utils/la-2k1000-sim`，修改 `buildfs.sh`。将原有的 `mount` 逻辑替换为 `mtools` 逻辑（使用 `mmd` 创建目录，`mcopy` 拷贝文件），这样无需 sudo 权限即可完成镜像制作。

   修改后的 `buildfs.sh` 脚本内容如下：
   ```
    #!/bin/bash

    # sudo 封装（mtools 不需要 sudo）
    SUDO=""

    # FAT32 镜像路径
    U_FAT32=$1
    BLK_SZ="512"
    TARGET=riscv64gc-unknown-none-elf
    MODE="release"

    # 解析参数
    if [ $# -ge 2 ]; then
        if [ "$2" = "2k1000" ] || [ "$2" = "laqemu" ]; then
            TARGET=loongarch64-unknown-linux-gnu
            BLK_SZ="2048"
        else
            TARGET=$2
        fi
    fi

    if [ $# -ge 3 ]; then
        MODE="$3"
    fi

    # 提取架构
    ARCH=$(echo "${TARGET}" | cut -d- -f1 | grep -o '[a-zA-Z]\+[0-9]\+')

    echo
    echo "Current arch: ${ARCH}"
    echo

    # 创建空镜像
    dd if=/dev/zero of="${U_FAT32}" bs=1M count=56
    echo "Making FAT32 image with BLK_SZ=${BLK_SZ}"
    mkfs.vfat -F 32 "${U_FAT32}" -S "${BLK_SZ}"

    # 检查 mtools 是否安装
    if ! command -v mmd >/dev/null || ! command -v mcopy >/dev/null; then
        echo "Please install mtools first (apt install mtools)"
        exit 1
    fi

    # mtools 配置临时使用镜像
    MTOOLSRC=$(mktemp)
    echo "drive z: file=\"$U_FAT32\" partition=0" > "$MTOOLSRC"

    # 创建目录结构
    mmd -i "$U_FAT32" ::/lib
    mmd -i "$U_FAT32" ::/etc
    mmd -i "$U_FAT32" ::/bin
    mmd -i "$U_FAT32" ::/root
    mmd -i "$U_FAT32" ::/syscall

    # 拷贝 libc.so
    if [ -f "../../tmp/testsuits-for-oskernel/runtime/${ARCH}/lib64/libc.so" ]; then
        mcopy -i "$U_FAT32" "../../tmp/testsuits-for-oskernel/runtime/${ARCH}/lib64/libc.so" ::/lib/
    elif [ -f "../user/lib/${ARCH}/libc.so" ]; then
        mcopy -i "$U_FAT32" "../user/lib/${ARCH}/libc.so" ::/lib/
    fi

    # passwd 文件
    echo -e "root:x:0:0:root:/root:/bash" > /tmp/passwd.tmp
    mcopy -i "$U_FAT32" /tmp/passwd.tmp ::/etc/passwd
    rm /tmp/passwd.tmp

    # bash_history 文件
    touch /tmp/.bash_history
    mcopy -i "$U_FAT32" /tmp/.bash_history ::/root/
    rm /tmp/.bash_history

    # 拷贝用户程序
    USER_BIN_DIR="../../NoAxiom-OS-User/bin"
    if [ -d "$USER_BIN_DIR" ]; then
        for prog in "$USER_BIN_DIR"/*; do
            mcopy -i "$U_FAT32" "$prog" ::/bin/
        done
    else
        echo "User bin directory not found: $USER_BIN_DIR"
    fi

    echo "DONE"

   ```

3. **生成镜像**
   ```bash
   chmod +x buildfs.sh
   ./buildfs.sh ../../NoAxiom-OS-Test/rootfs-riscv.img
   ```
---

## 四、 解决镜像自动覆盖问题

项目自带的 Makefile 在运行 `make run` 时会调用 `extract.sh` 脚本，用一个原始的“干净”镜像覆盖掉我们修改后的镜像。为了保留注入的文件，需要执行以下操作：

1. **修改 Makefile**

   编辑 `NoAxiom-OS-Test/Makefile`，找到 `extract:` 目标，将调用脚本的行注释掉：
   ```makefile
   extract: $(FS_IMG_GZ)
   #       $(EXTRACT_SCRIPT) $(FS_IMG_GZ) $(TEST_IMG)  <-- 注释掉此行
   ```

---

## 五、 手动注入 Busybox 与测试用例

当内核报错 `Vfs::link: sh already exists` 或文件丢失时，使用 `debugfs` 工具直接对磁盘镜像进行操作，注入我们在第二步编译好的 Busybox 和用户态测试程序。

1. **注入二进制文件**
   ```bash
    # 路径请根据你的实际环境调整
    IMG_PATH="/root/NoAxiom-OS/NoAxiom-OS-Test/official/tmp-img/fs-rv-pre-2025.img"
    BUSYBOX_SRC="/root/NoAxiom-OS/busybox/busybox"

    debugfs -w $IMG_PATH <<EOF
    cd /bin
    rm busybox
    rm sh
    rm cat
    rm ls
    # ... (根据报错依次删除冲突的二进制文件) ...
    write $BUSYBOX_SRC busybox
    chmod 755 busybox
    quit
    EOF
   ```

2. **注入测试引导程序 run_tests**
   ```bash
   RUN_TESTS_SRC="/root/NoAxiom-OS/NoAxiom-OS-User/bin/run_tests"
   
   # 验证 run_tests 类型
   readelf -h $RUN_TESTS_SRC | grep Type

   debugfs -w $IMG_PATH <<EOF
   rm /run_tests
   write $RUN_TESTS_SRC /run_tests
   chmod 755 /run_tests
   mkdir /usr
   mkdir /usr/bin
   quit
   EOF
   ```

---

## 六、 建立测试用例映射（解决 test_ 前缀问题）

内核测试脚本在 `/musl/basic` 中寻找 `test_unlink` 等文件，而镜像中原始文件名为 `unlink`。

**批量建立硬链接**：
   ```bash
   debugfs -w $IMG_PATH <<EOF
   cd /musl/basic
   link unlink test_unlink
   link brk test_brk
   link chdir test_chdir
   link clone test_clone
   link close test_close
   link dup test_dup
   link dup2 test_dup2
   link execve test_execve
   link exit test_exit
   link fork test_fork
   link fstat test_fstat
   link getcwd test_getcwd
   link getdents test_getdents
   link getpid test_getpid
   link getppid test_getppid
   link gettimeofday test_gettimeofday
   link mkdir_ test_mkdir
   link mmap test_mmap
   link mount test_mount
   link munmap test_munmap
   link open test_open
   link openat test_openat
   link pipe test_pipe
   link read test_read
   link sleep test_sleep
   link times test_times
   link umount test_umount
   link uname test_uname
   link wait test_wait
   link waitpid test_waitpid
   link write test_write
   link yield test_yield
   quit
   EOF
   ```

---

## 七、 运行测试

回到项目根目录，设置初始化进程为测试程序并启动：

   ```bash
   export INIT_PROC=run_tests
   export LOG=WARN
   cd /root/NoAxiom-OS
   make run
   ```

此时系统将正常加载 `run_tests`，并通过 `busybox` 提供的基础环境调用 `/musl/basic` 下的各项系统调用测试。观察日志输出，确认各项测试点是否通过。
---

## 八、 LoongArch64 模拟器环境扩展

如果你需要运行 LoongArch 架构，通常需要自行编译支持该架构的 QEMU。

### 1. 编译 LoongArch 版 QEMU
```bash
# 安装依赖
apt-get install -y libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev

# 编译 QEMU
git clone https://gitlab.com/qemu-project/qemu.git
cd qemu
./configure --target-list=loongarch64-softmmu
make -j$(nproc)
```

### 2. 启动 LoongArch 内核
```bash
./build/loongarch64-softmmu/qemu-system-loongarch64 \
  -machine virt \
  -bios ./NoAxiom-OS-Utils/toolchain/rustsbi-qemu.bin \
  -m 512M \
  -nographic \
  -kernel ./NoAxiom/target/loongarch64-unknown-none/release/kernel \
  -initrd ./NoAxiom-OS-Test/rootfs-la.img \
  -append "root=/dev/ram rw console=ttyAMA0"
```

---

## 九、 运行与验证
完成上述步骤后，回到项目根目录：
```bash
# 确保启动项正确
export INIT_PROC=run_tests
make run
```
此时，控制台应能正常加载 `busybox`，并顺序执行 `/musl/basic` 下的各项系统调用测试。观察日志输出，确认所有测试点是否通过。